
### Testing

![image-20230605152853140](../img/5.25/image-20230605152853140.png)

测试分成人工测试（单元测试、集成测试、系统测试），模糊测试，符号化具体测试（通过静态分析的方式）。

### Fuzzing

模糊测试是随机生成输入来进行测试。我们给程序随机的输入，直到程序crash。

![image-20230605152911617](../img/5.25/image-20230605152911617.png)

找到bug不一定导致crash(一般memory的bug会导致crash)，所以我们需要定义怎样算找到bug。

![image-20230605152924306](../img/5.25/image-20230605152924306.png)

#### 如何生成输入

-  just generate random binary data. `cat /dev/urandom | xml_parser`，但是事实上这种方式效果不好，因为随机生成的输入不一定能通过header check，有很多都是无效输入。![image-20230606195521045](../img/5.25/image-20230606195521045.png)
- Structured inputs (a.k.a. structure-aware fuzzing). 生成一些有结构信息的输入，对于xml文件先把语法提取出来，我们通过语法来生成合法的xml文件。![image-20230606195646820](../img/5.25/image-20230606195646820.png)
- Generating better inputs for programs. 我们要生成的输入要尽可能地覆盖程序的所有basic block。更进一步，我们希望能够覆盖所有的路径（所有分支的排列组合），这比覆盖所有的的branch代价更高。
  - Coverage wall：有些分支非常难以进入，好像一堵墙隔着一样，导致覆盖率无法上升。![image-20230606200506116](../img/5.25/image-20230606200506116.png)这时我们可以利用符号求解去求解如何进入那些难以进入的分支。

- How to measure code coverage![image-20230612133411932](../img/6.7/image-20230612133411932.png)

#### 如何找到bug

有些bug并不会立即导致系统crash，而还有些bug不会导致系统crash。

![image-20230612133815311](../img/6.7/image-20230612133815311.png)

![image-20230612133837041](../img/6.7/image-20230612133837041.png)

![image-20230612133847716](../img/6.7/image-20230612133847716.png)

![image-20230612133857851](../img/6.7/image-20230612133857851.png)

#### 如何自动化过程

![image-20230612134313796](../img/6.7/image-20230612134313796.png)

![image-20230612134325365](../img/6.7/image-20230612134325365.png)

![image-20230612134338959](../img/6.7/image-20230612134338959.png)

![image-20230612134350694](../img/6.7/image-20230612134350694.png)



![image-20230612134828015](../img/6.7/image-20230612134828015.png)

### Summary

![image-20230612135402172](../img/6.7/image-20230612135402172.png)

![image-20230612135408667](../img/6.7/image-20230612135408667.png)

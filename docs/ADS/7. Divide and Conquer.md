### 1. 概述

`General recurrence:   T(N) = aT(N/b) + f(N)`把问题分成a个子问题，每个子问题的问题规模为原来的1/b，合并的时间复杂度为f(N)，如上公式就是这个意思。

一些可以被`divide and conquer`解决的问题：

- The maximu m subsequence sum 连续的子序列的和最大值 – the O( N log N ) solution
- Tree traversals （树的遍历）– O( N )
- Mergesort and quicksort –  O( N log N ) 

combine对算法的时间复杂度的影响：

![image-20230411170625381](../img/3.30/image-20230411170625381.png)

### 2. 最近点对问题

#### 问题背景

在应用中，常用诸如点、圆等简单的几何对象代表现实世界中的实体。在涉及这些几何对象的问题中，常需要了解其邻域中其他几何对象（**最接近**）的信息。例如，在空中交通控制问题中，若将飞机作为空间中移动的一个点来看待，则具有最大碰撞危险的2架飞机，就是这个空间中最接近的一对点。这类问题是计算几何学中研究的基本问题之一

#### 具体方法

已知集合S中有n个点，使用分治法的思想就是将S进行拆分，分为2部分求最近点对。算法每次选择一条垂线L，将S拆分左右两部分为SL和SR，( L一般取点集S中所有点的中间点的x坐标来划分，这样可以保证SL和SR中的点数目各为n/2 否则以其他方式划分S，有可能导致SL和SR中点数目一个为1，一个为n-1，不利于算法效率，要尽量保持树的平衡性 )

![image-20230411110742729](../img/3.30/image-20230411110742729.png)

![image-20230411110925142](../img/3.30/image-20230411110925142.png)

![image-20230411182356599](../img/3.30/image-20230411182356599.png)

#### 具体算法

- 如果只有两个点，那么直接输出；
- 根据横坐标，分成两个组，分别调用，求出两边各自最小的距离；
- 求出两边最小的距离a；
- 求出距离中心线a内的所有点，然后根据y坐标进行排序生成点对数组ptr；
- 对ptr中的每一个点进行遍历
  - 如果是中心线右边的点，直接跳过；
  - 只需与相邻的6个点进行比较；![image-20230411191300189](../img/3.30/image-20230411191300189.png)

### 3. 分析

三种分析时间复杂度的方法：代入法（数学归纳法）、递归树方法（猜一个好的结果）、Master method(主定理)法；

![image-20230411191822115](../img/3.30/image-20230411191822115.png)

#### 3.1 代入法示例

`T( N ) = 2 T( [N / 2] ) + N(向下取整)`

![image-20230411192035896](../img/3.30/image-20230411192035896.png)

![image-20230411193234201](../img/3.30/image-20230411193234201.png)必须得是cN，不能是（c+1)N，所以不行；

#### 3.2 递归树方法

找规律，一直分解到最后一层

![image-20230411193609477](../img/3.30/image-20230411193609477.png)

![image-20230411193854407](../img/3.30/image-20230411193854407.png)

![image-20230411193900905](../img/3.30/image-20230411193900905.png)

![image-20230411193929515](../img/3.30/image-20230411193929515.png)

![image-20230411194006526](../img/3.30/image-20230411194006526.png)

![image-20230411194210251](../img/3.30/image-20230411194210251.png)

![image-20230411194230207](../img/3.30/image-20230411194230207.png)

**再来一个例子：**

![image-20230411194537662](../img/3.30/image-20230411194537662.png)

再利用归纳法进行证明

![image-20230411194608719](../img/3.30/image-20230411194608719.png)

#### 3.3 Master method

![image-20230411194742664](../img/3.30/image-20230411194742664.png)![image-20230411203044265](../img/3.30/image-20230411203044265.png)![image-20230411203032673](../img/3.30/image-20230411203032673.png)

其实就是比较f(N)和N^log~b~a^的大小关系，第一种情况是后者大，那么就以后者为主；第二种情况是渐进意义上的相等；第三种情况是，前者比较大，而且满足一些关系，那么就以前者为主。

![image-20230411200016309](../img/3.30/image-20230411200016309.png)

后者不满足case3的第二个条件

此定理可以通过递归树进行证明

![image-20230411200048142](../img/3.30/image-20230411200048142.png)

case1证明：

![image-20230411200752743](../img/3.30/image-20230411200752743.png)

case2 和 case3 的证明看书。

**另一个形式：**

![image-20230411202307030](../img/3.30/image-20230411202307030.png)

前面那个可以证明，但这个不能证明  

![image-20230411204455689](../img/3.30/image-20230411204455689.png)

**最强大的定理：**

![image-20230411204846614](../img/3.30/image-20230411204846614.png)

> 2022bjj、2022yds

hw7 2-2不太懂！
hw7 2-3不太懂！
![image-20230411210936762](../img/3.30/image-20230411210936762.png)

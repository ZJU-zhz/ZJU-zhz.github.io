### Three A

- 安全区分授权访问和未授权访问，保密性、完整性和可用性（CIA）都要求做到这一点；
- 身份验证（Authentication）：弄清楚谁在访问；
    - something you know：用户名和密码；
    - something you have：偏向于硬件，比如smart card或者tokens；
    - something you are：生物信息；
- 访问控制（Access control）：确保只允许授权访问；
- 审计（Auditing）：记录正在发生的事情，也就是访问过程被监控，以便以后识别攻击并进行恢复；

### Threats to Passwords

- 信道（Channel）：在用户端连接到服务端的信道上进行窃取；
- 用户端（login spoofing）：钓鱼网站，或者监测键盘活动等；
- 服务端（offline dictionary attacks）：直接攻击服务器，获取数据库；
- Social engineering：human errors；
- Online guessing：主要针对弱密码；

#### Online guessing

**猜测攻击：密码强度的两个因素**

- 攻击者必须进行的平均猜测次数才能找到正确的密码：由密码的不可预测性决定，包括密码的长度、
  它是由哪些符号绘制的，以及它是如何创建的。
- 攻击者检查猜测的密码的有效性的轻松程度：由密码的存储方式、检查方式以及尝试的任何限制决定；

**Password Entropy**

- 口令熵，也就是不确定性；

![image-20230429130633954](../img/4.27/image-20230429130633954.png)

- 熵每加一，攻击者的尝试次数就要$\times2$；

**根据口令熵的原理进行密码的推荐**

**一些不好的密码举例**

**一些方法去增加密码强度**

- 允许长字符密码，禁止短密码

- 在适当的情况下随机生成密码

- 为用户提供选择密码的建议/指南
    - 例如，思考一个句子并从中选择字母，“现在是中午12点“；
    - 同时使用字母、数字和特殊字符；

- 检查用户选择的密码的质量
    - 使用一些经验法则；运行字典攻击工具
    - 评估密码的强度并解释其弱点

**当然要在密码强度和用户友好性上进行权衡**

#### 服务器端

当一个服务器被攻破之后，如何保护密码：

**哈希算法（单向性的函数）**
**加密方法**：在服务器端存储的是Hash(password)，用户输入password后，进行哈希加密后与服务端进行比对；
**局限性**：还是容易泄露一部分信息，或者可以直接暴力匹配；另外，如果用户端密码相同，那么服务端的两个加密值也相同，那么攻破一个就相当于攻破两个，而且还可以使用频率分析法进行破解；
**改进**：因此，我们可以再加一些不确定性，算法变成H(password, r1)，只要r不相等，加密出来的值就不相等；

服务端如何保护存储的密码（同时使用加密和访问控制）：

- 使用多种独立的防御方法，这样即使一层失败，安全性仍然不会受到损害。
- 禁用多次尝试失败的帐户。
- 需要额外的身份验证机制（例如，电话、其他电子邮件帐户等）。

#### 用户端

**用户程序**

在运行一个程序的时候，会定时地进行时间片的打断，而这有可能在两个时间片之间被木马程序劫持，我们可以提高程序的权限，这样当程序运行的时候，权限比程序低的木马就无法完成劫持。

**钓鱼网站防御方法**

- 已知钓鱼网站的浏览器过滤
- 服务器的加密身份验证
- 用户配置的服务器身份验证
    - 确保网站是人类用户心中想要访问的网站。例如，站点密钥、预先选择的图片/短语

#### 信道端

- 一次性密码：每个密码只使用一次，防御被动的窃听者和后来的试图模仿的窃听者；
- 挑战响应：发送与密码和质询相关的响应；
- 零知识知识证明：证明对秘密价值的了解，而不泄露任何关于秘密（比如要知道平均成绩而不能知道每一个人的成绩）；


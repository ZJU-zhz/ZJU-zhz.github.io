```toc
```
### Quicksort
#### 1.时间

- 前者为归并排序的递归式，后者为快速排序的递归式；

- ![image-20221206081133837](../../img/test/202212060811908.png)

- 他们都是最慢n^2^，最快nlogn；

- ![image-20221206084844760](../../img/test/202212060848779.png)

#### 2. 步骤

1. pivot[[fds_lec11#4.1 算法]]；
2. partition（不额外占用空间）[[fds_lec11#4.1 算法]]；

#### 3. 空间复杂度
- O（log2n）；因为递归需要堆栈的空间，需要空间，平均情况是log2n；

#### 4. 代码实现
##### 4.1 总体思路
- ![image-20221206082901988](../../img/test/202212060829005.png)
##### 4.2 总的函数
- ![image-20221206082846662](../../img/test/202212060828720.png)
##### 4.3 寻找pivot

- 首先![image-20221206083358714](../../img/test/202212060833748.png)
- 然后![image-20221206083414502](../../img/test/202212060834522.png)
- 最后返回

- ![image-20221206083007388](../../img/test/202212060830403.png)

##### 4.4 主要函数

- 先判断是否需要快速排序![image-20221206083749335](../../img/test/202212060837371.png)
- 寻找pivot
- 双向扫描

- ![image-20221206083451489](../../img/test/202212060834508.png)

#### 5. 一个额外的问题：找到第k大的元素

- 排序；
- 建堆，删除k次；
- 找pivot，如果比pivot的小的数组有k-1个，那刚好，如果大于k-1，就在小的数组里面继续找pivot，如果小于k-1，就在大的数组里面找；

### Sorting Large Structures

- 排大结构时候不要挪动对象本身，设定一个table；
- 然后知道最后的位置后，进行换位；
- ![image-20221206091814417](../../img/test/202212060918491.png)

### A General Lower Bound for Sorting（决策树）

- ![image-20221206092903857](../../img/test/202212060929889.png)

###  Bucket Sort and Radix Sort
#### Bucket Sort
- 数字范围较小，桶排序；
- ![image-20221206093136503](../../img/test/202212060931534.png)

#### Radix Sort
- 数字范围较大，基数排序；
- 第一步根据个位数，扔到桶里去；
- 然后根据十位数，根据百位数......
- ![image-20221206093547427](../../img/test/202212060935451.png)



